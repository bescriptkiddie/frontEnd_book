## http 协议篇

#### tcp 三次握手和四次挥手

tcp 三次握手
所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送 3 个包。
三次握手的目的是连接服务器指定端口，建立 TCP 连接,并同步连接双方的序列号和确认号并交换 TCP 窗口大小信息.在 socket 编程中，客户端执行 connect()时。将触发三次握手

1. 第一次握手
   客户端发送一个 TCP 的 SYN 标志位置 1 的包指明客户打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。
2. 第二次握手
   服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为 1 同时，将确认序号(Acknowledgement Number)设置为客户的 I S N 加 1 以.即 X+1。
   服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为 1 同时，将确认序号(Acknowledgement Number)设置为客户的 I S N 加 1 以.即 X+1。 3.第三次握手
   客户端再次发送确认包(ACK)SYN 标志位为 0,ACK 标志位为 1.并且把服务器发来 ACK 的序号字段+1,放在确定字段中发送给对方.并且在数据段放写 ISN 的+1

TCP 四次挥手
TCP 的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close()操作即可产生挥手操作。

为什么建立连接是三次握手，而关闭连接却是四次挥手呢？

这是因为服务端在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。而关闭连接时，当收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即 close，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送。

#### http request 由哪些组成？

状态行、请求头、消息主体三部分组成

#### HTTP 有哪些方法？

HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法
HTTP1.1 新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT

#### 200 304 缓存区别

浏览器缓存

- 浏览器在请求某一资源时，会先获取该资源缓存的 header 信息，判断是否命中强缓存（cache-control 和 expires 信息），若命中直接从缓存中获取资源信息，包括缓存 header 信息，本次请求就不会与服务器进行通信。

- 如果没有命中强缓存，浏览器会发送请求到服务器，请求会携带第一次返回的有关缓存的 header 字段信息（Last-Modifued/If-Modified-Since 和 Etag/If-None-Match），由服务器根据 header 信息来比对结果是否协商缓存命中。若命中，则服务器返回新的响应 header 信息更新缓存中的对应 header 信息，但是不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容。

强缓存相关 header 字段

Expires 策略
Expires 是 Web 服务器响应消息头字段，在响应 http 请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。
Expires 设置失效时间，精确到时分秒。
不过 Expires 是 HTTP 1.0 的东西，现在默认浏览器均默认使用 HTTP 1.1，所以它的作用基本忽略。
http 协议头 Cache-Control ：值可以是 public、private、no-cache、no- store、no-transform、must-revalidate、proxy-revalidate、max-age

协商缓存相关的 header 字段

Last-Modifued/If-Modified-Since 和 Etag/If-None-Match 这两组搭档都是成对出现的，即第一次请求的响应头带上某个字段（Last-Modifued 或者 Etag），则后续请求会带上对应的请求字段（If-Modified-Since 或者 If-None-Match），若响应头没有 Last-Modifued 或者 Etag 字段，则请求头也不会有对应字段

#### OSI 七层协议、http 是哪个层 tcp/udp 呢(某站)

OSI 七层模型每一层都有自己的作用，从上到下的作用依次为：

- 应用层(Application) :提供网络与用户应用软件之间的接口服务
- 表示层(Presentation) :提供格式化的表示和转换数据服务，如加密和压缩
- 会话层(Session) 提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制
- 传输层(Transimission):提供建立、维护和取消传输连接功能，负责可靠地传输数据(PC)
- 网络层(Network): 处理网络间路由，确保数据及时传送(路由器)
- 数据链路层(DataLink): 负责无错传输数据，确认帧、发错重传等(交换机)
- 物理层(Physics) :提供机械、电气、功能和过程特性(网卡、网线、双绞线、同轴电缆、中继器)

http 属于应用层
tcp/udp 属于传输层

#### GET 和 POST 有什么区别？

数据传输方式不同：GET 请求通过 URL 传输数据，而 POST 的数据通过请求体传输。

安全性不同：POST 的数据因为在请求主体内，所以有一定的安全性保证，而 GET 的数据在 URL 中，通过历史记录，缓存很容易查到数据信息。

数据类型不同：GET 只允许 ASCII 字符，而 POST 无限制

GET 无害： 刷新、后退等浏览器操作 GET 请求是无害的，POST 可能重复提交表单

特性不同：GET 是安全（这里的安全是指只读特性，就是使用这个方法不会引起服务器状态变化）且幂等（幂等的概念是指同一个请求方法执行多次和仅执行一次的效果完全相同），而 POST 是非安全非幂等

#### PUT 和 POST 都是给服务器发送新增资源，有什么区别？

PUT 和 POST 方法的区别是,PUT 方法是幂等的：连续调用一次或者多次的效果相同（无副作用），而 POST 方法是非幂等的。
除此之外还有一个区别，通常情况下，PUT 的 URI 指向是具体单一资源，而 POST 可以指向资源集合。

#### PUT 和 PATCH 都是给服务器发送修改资源，有什么区别？

PUT 和 PATCH 都是更新资源，而 PATCH 用来对已知资源进行局部更新。

#### 聊一聊 HTTP 的状态码有哪些？

2XX 成功

- 200 OK，表示从客户端发来的请求在服务器端被正确处理
  3XX 重定向
- 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL
- 302 found，临时性重定向，表示资源临时被分配了新的 URL
- 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况

4XX 客户端错误

- 400 bad request，请求报文存在语法错误
- 404 not found，表示在服务器上没有找到请求的资源

5XX 服务器错误

- 500 internal sever error，表示服务器端在执行请求时发生了错误
- 505 http version not supported 服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本

#### HTTP 的 keep-alive 是干什么的？

在早期的 HTTP/1.0 中，每次 http 请求都要创建一个连接，而创建连接的过程需要消耗资源和时间，为了减少资源消耗，缩短响应时间，就需要重用连接。在后来的 HTTP/1.0 中以及 HTTP/1.1 中，引入了重用连接的机制，就是在 http 请求头中加入 Connection: keep-alive 来告诉对方这个请求响应完成后不要关闭，下一次咱们还用这个请求继续交流。协议规定 HTTP/1.0 如果想要保持长连接，需要在请求头中加上 Connection: keep-alive。

keep-alive 的优点：

- 较少的 CPU 和内存的使用（由于同时打开的连接的减少了）
- 允许请求和应答的 HTTP 管线化
- 降低拥塞控制 （TCP 连接减少了）
- 减少了后续请求的延迟（无需再进行握手）
- 报告错误无需关闭 TCP 连

#### 为什么有了 HTTP 为什么还要 HTTPS？

https 是安全版的 http，因为 http 协议的数据都是明文进行传输的，所以对于一些敏感信息的传输就很不安全，HTTPS 就是为了解决 HTTP 的不安全而生的。

#### HTTP2 相对于 HTTP1.x 有什么优势和特点？

二进制分帧

帧：HTTP/2 数据通信的最小单位消息：指 HTTP/2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由一个或多个帧组成。
流：存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数 ID
HTTP/2 采用二进制格式传输数据，而非 HTTP 1.x 的文本格式，二进制协议解析起来更高效。

服务器推送

服务端可以在发送页面 HTML 时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。例如服务端可以主动把 JS 和 CSS 文件推送给客户端，而不需要客户端解析 HTML 时再发送这些请求。
服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送 RST_STREAM 帧来拒收。主动推送也遵守同源策略，服务器不会随便推送第三方资源给客户端。

头部压缩

HTTP/1.x 会在请求和响应中中重复地携带不常改变的、冗长的头部数据，给网络带来额外的负担。

多路复用

HTTP 1.x 中，如果想并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8 个的 TCP 链接请求限制。

#### http 和 https 的区别

http 协议的报文传输时不加密的，有些隐私信息存在被窃听的风险
http 协议通信时无法验证通信方身份，可能存在伪装者（客户端、服务器）
http 协议无法判断通信报文的完整性，通信报文在 TCP/IP 协议通信中可能会被篡改

https 协议是 http 协议+ssl 协议组成的，那么 http 协议的缺点，只能是 ssl 协议来完成
信任主机的问题.。 采用 https 的 server 必须从 CA （数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的 立场上）申请一个用于证明服务器用途类型的证书
HTTP + 认证 + 加密 + 完整性保护 = HTTPS
TCP 用的 port 是 80， https 用的是 443

#### http 缓存头部字段

简单说说 HTTP 协议中缓存相关的头字段

- If-Modified-Since

对应 Last-modified。服务器返回资源时，会携带 Last-modified，表示该资源最后修改的时间。客户端如果缓存数据，就需要把这个时间保存起来，在下一次请求的时候用 If-Modified-Since 带上，让服务器判断资源的最后修改时间是否一致。如果一致，就返回 304，让客户端直接使用本地缓存。否则说明资源被修改，返回新资源和新的 Last-modified。

- Last-modified
  资源最后修改时间，配合 If-Modified-Since 使用。属于响应头字段。
- ETag
  资源的特定版本标识符，可以类比软件的版本号，需要配合 If-None-Match 使用。另外，这个 E 是 Entity（实体）的意思。
- If-None-Match
  效果类似 If-Modified-Since，客户端第一次请求资源时会拿到响应头里的 ETag 字段，将其保存起来。下次请求时，就作为 If-None-Match 头字段的值进行请求。ETag 通常使用的是弱比较算法，即如果两个资源语义一致，可看作为匹配成功。如果匹配成功，返回 304，否则返回新资源和新的 ETag。另外，ETag 通常会用 W/ 开头，表示使用了弱匹配算法。ETag 可以用于跟踪用户，某种程度上，可以作为 cookie 的替代品。该头字段的优先度比 If-Modified-Since 高。
- Cache-Control
  通用消息头字段，在请求头和响应头中有不同的语义，用于实现缓存控制。
  在响应头中，有很多值可以选择
  max-age=<seconds> 表示服务器提供的资源的有效期，单位为秒。
  no-store 表示不允许客户端进行缓存。这个通常用于动态页面，比如微博首页。
  no-cache 表示客户端每次使用本地缓存前，要要先去服务器验证。
